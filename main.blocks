<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="+EjvQ]iJ8o]#@IzZ:fm$" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id=":9`-8n#A7[x*Gk%xs+aq" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace CollisionHandler {" line1="" line2="    export enum PushDirection {" line3="        X_Axis," line4="        Y_Axis," line5="        Omnidirectional" line6="    }" line7="" line8="    // Stops spriteA when colliding with spriteB (acts like a wall)" line9="    //% block=&quot;stop $spriteA when colliding with $spriteB&quot;" line10="    //% group=&quot;Solid Collisions&quot;" line11="    //% spriteA.shadow=variables_get" line12="    //% spriteA.defl=mySprite" line13="    //% spriteB.shadow=variables_get" line14="    //% spriteB.shadow=spritekind" line15="    export function handleSolidCollision(spriteA: Sprite | number, spriteB: Sprite | number) {" line16="        handleAABBCollision(spriteA, spriteB, false, PushDirection.Omnidirectional);" line17="    }" line18="" line19="    // Allows spriteA to push spriteB" line20="    //% block=&quot;allow $spriteA to push $spriteB in $direction&quot;" line21="    //% group=&quot;Pushable Collisions&quot;" line22="    //% spriteA.shadow=variables_get" line23="    //% spriteA.defl=mySprite" line24="    //% spriteB.shadow=variables_get" line25="    //% spriteB.shadow=spritekind" line26="    //% direction.defl=CollisionHandler.PushDirection.Omnidirectional" line27="    //% color=&quot;#a349a4&quot; weight=80" line28="    export function handlePushableCollision(spriteA: Sprite | number, spriteB: Sprite | number, direction: PushDirection) {" line29="        handleAABBCollision(spriteA, spriteB, true, direction);" line30="    }" line31="" line32="    function handleAABBCollision(spriteA: Sprite | number, spriteB: Sprite | number, pushable: boolean, direction: PushDirection) {" line33="        game.onUpdate(function () {" line34="            let spritesA: Sprite[] = typeof spriteA === &quot;number&quot; ? sprites.allOfKind(spriteA) : [spriteA];" line35="            let spritesB: Sprite[] = typeof spriteB === &quot;number&quot; ? sprites.allOfKind(spriteB) : [spriteB];" line36="" line37="            for (let a of spritesA) {" line38="                for (let b of spritesB) {" line39="                    if (a === b) continue;" line40="" line41="                    let boxA = getBoundingBox(a);" line42="                    let boxB = getBoundingBox(b);" line43="" line44="                    if (isAABBOverlapping(boxA, boxB)) {" line45="                        let overlapX = Math.min(boxA.right - boxB.left, boxB.right - boxA.left);" line46="                        let overlapY = Math.min(boxA.bottom - boxB.top, boxB.bottom - boxA.top);" line47="" line48="                        let moveX = 0;" line49="                        let moveY = 0;" line50="" line51="                        // Determine movement direction based on the smaller overlap" line52="                        if (overlapX &lt; overlapY) {" line53="                            moveX = a.x &gt; b.x ? -overlapX : overlapX;" line54="                        } else {" line55="                            moveY = a.y &gt; b.y ? -overlapY : overlapY;" line56="                        }" line57="" line58="                        if (pushable) {" line59="                            // Restrict movement based on push direction" line60="                            if (direction === PushDirection.X_Axis) {" line61="                                moveY = 0;" line62="                            } else if (direction === PushDirection.Y_Axis) {" line63="                                moveX = 0;" line64="                            }" line65="" line66="                            let newX = b.x + moveX;" line67="                            let newY = b.y + moveY;" line68="" line69="                            // Check if the pushable object will hit a wall or move out of bounds" line70="                            if (isOnWallTile(newX, newY) || isOutOfBounds(newX, newY, b)) {" line71="                                handleSolidCollision(a, b);" line72="                                a.vx = 0; // Stop player movement" line73="                                a.vy = 0;" line74="                            } else {" line75="                                b.setPosition(newX, newY);" line76="                            }" line77="" line78="                        } else {" line79="                            let newX2 = clamp(a.x - moveX, spriteMinX(a), spriteMaxX(a));" line80="                            let newY2 = clamp(a.y - moveY, spriteMinY(a), spriteMaxY(a));" line81="" line82="                            // Prevent player from moving past tilemap boundaries" line83="                            if (!isOutOfBounds(newX2, newY2, a)) {" line84="                                a.setPosition(newX2, newY2);" line85="                            }" line86="                            a.vx = 0;" line87="                            a.vy = 0;" line88="                        }" line89="                    }" line90="                }" line91="            }" line92="        });" line93="    }" line94="" line95="    // Checks if a given position collides with a wall tile" line96="    function isOnWallTile(x: number, y: number): boolean {" line97="        let tilemap = game.currentScene().tileMap;" line98="        if (!tilemap) return false;" line99="" line100="        let tempSprite = sprites.create(img`.`); // Create a temporary sprite for collision check" line101="        tempSprite.setPosition(x, y);" line102="        let onWall = tilemap.isOnWall(tempSprite);" line103="        tempSprite.destroy(); // Remove temporary sprite" line104="" line105="        return onWall;" line106="    }" line107="" line108="    // Checks if a position is outside the tilemap boundaries" line109="    function isOutOfBounds(x: number, y: number, sprite: Sprite): boolean {" line110="        let tilemap2 = game.currentScene().tileMap;" line111="        if (!tilemap2) return false;" line112="" line113="        let minX = spriteMinX(sprite);" line114="        let minY = spriteMinY(sprite);" line115="        let maxX = spriteMaxX(sprite);" line116="        let maxY = spriteMaxY(sprite);" line117="" line118="        return x &lt; minX || x &gt; maxX || y &lt; minY || y &gt; maxY;" line119="    }" line120="" line121="    // Gets the bounding box of a sprite" line122="    function getBoundingBox(sprite: Sprite): { left: number, right: number, top: number, bottom: number } {" line123="        return {" line124="            left: sprite.left," line125="            right: sprite.right," line126="            top: sprite.top," line127="            bottom: sprite.bottom" line128="        };" line129="    }" line130="" line131="    // Checks if two bounding boxes overlap" line132="    function isAABBOverlapping(boxA: { left: number, right: number, top: number, bottom: number }," line133="        boxB: { left: number, right: number, top: number, bottom: number }): boolean {" line134="        return (" line135="            boxA.left &lt; boxB.right &amp;&amp;" line136="            boxA.right &gt; boxB.left &amp;&amp;" line137="            boxA.top &lt; boxB.bottom &amp;&amp;" line138="            boxA.bottom &gt; boxB.top" line139="        );" line140="    }" line141="" line142="    // Restricts a value within a given range" line143="    function clamp(value: number, min: number, max: number): number {" line144="        return Math.max(min, Math.min(max, value));" line145="    }" line146="" line147="    // Gets the minimum X position allowed for a sprite" line148="    function spriteMinX(sprite: Sprite): number {" line149="        return sprite.width / 2;" line150="    }" line151="" line152="    // Gets the maximum X position allowed for a sprite within the tilemap" line153="    function spriteMaxX(sprite: Sprite): number {" line154="        let tilemap3 = game.currentScene().tileMap;" line155="        return tilemap3 ? tilemap3.areaWidth() - sprite.width / 2 : scene.screenWidth();" line156="    }" line157="" line158="    // Gets the minimum Y position allowed for a sprite" line159="    function spriteMinY(sprite: Sprite): number {" line160="        return sprite.height / 2;" line161="    }" line162="" line163="    // Gets the maximum Y position allowed for a sprite within the tilemap" line164="    function spriteMaxY(sprite: Sprite): number {" line165="        let tilemap4 = game.currentScene().tileMap;" line166="        return tilemap4 ? tilemap4.areaHeight() - sprite.height / 2 : scene.screenHeight();" line167="    }" line168="}" numlines="169"></mutation></block></statement></block></xml>