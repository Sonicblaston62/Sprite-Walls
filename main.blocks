<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="xG^bib|!NM#j{+UJok;," x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="i.7G|=C@yD]9$%o4T|NX" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace SpriteCollisions {" line1="" line2="    /**" line3="     * Stops spriteA when colliding with spriteB (acts like a wall)." line4="     * @param spriteA The first sprite (the one that moves)." line5="     * @param spriteB The second sprite or a SpriteKind (stationary object)." line6="     */" line7="    //% block=&quot;stop $spriteA when colliding with $spriteB&quot;" line8="    //% blockId=spriteCollisions_handleSolidCollision" line9="    //% group=&quot;Solid Collisions&quot;" line10="    //% spriteA.shadow=variables_get" line11="    //% spriteA.defl=mySprite" line12="    //% spriteB.shadow=variables_get" line13="    //% spriteB.shadow=spritekind" line14="    //% color=&quot;#a349a4&quot; weight=90" line15="    export function handleSolidCollision(spriteA: Sprite | number, spriteB: Sprite | number) {" line16="        handleAABBCollision(spriteA, spriteB, false);" line17="    }" line18="" line19="" line20="    /**" line21="     * Allows spriteA to push spriteB (pushable object)." line22="     * @param spriteA The first sprite (the one that moves)." line23="     * @param spriteB The second sprite or a SpriteKind (pushable object)." line24="     */" line25="    //% block=&quot;allow $spriteA to push $spriteB&quot;" line26="    //% group=&quot;Pushable Collisions&quot;" line27="    //% spriteA.shadow=variables_get" line28="    //% spriteA.defl=mySprite" line29="    //% spriteB.shadow=variables_get" line30="    //% spriteB.shadow=spritekind" line31="    //% color=&quot;#a349a4&quot; weight=80" line32="    export function handlePushableCollision(spriteA: Sprite | number, spriteB: Sprite | number) {" line33="        handleAABBCollision(spriteA, spriteB, true);" line34="    }" line35="" line36="    // =========================" line37="    // AABB Collision Handling" line38="    // =========================" line39="    function handleAABBCollision(spriteA: Sprite | number, spriteB: Sprite | number, pushable: boolean = false) {" line40="        game.onUpdate(function () {" line41="            let spritesToCheck: Sprite[] = [];" line42="" line43="            if (typeof spriteB === &quot;number&quot;) {" line44="                spritesToCheck = sprites.allOfKind(spriteB);" line45="            } else {" line46="                spritesToCheck = [spriteB];" line47="            }" line48="" line49="            for (let otherSprite of spritesToCheck) {" line50="                if (spriteA instanceof Sprite) {" line51="                    let boxA = getBoundingBox(spriteA, false);" line52="                    let boxB = getBoundingBox(otherSprite, false);" line53="" line54="                    if (isAABBOverlapping(boxA, boxB)) {" line55="                        let overlapX = Math.min(boxA.right - boxB.left, boxB.right - boxA.left);" line56="                        let overlapY = Math.min(boxA.bottom - boxB.top, boxB.bottom - boxA.top);" line57="" line58="                        if (overlapX &lt; overlapY) {" line59="                            if (spriteA.x &gt; otherSprite.x) {" line60="                                if (pushable) otherSprite.x -= overlapX;" line61="                                else spriteA.x += overlapX;" line62="                            } else {" line63="                                if (pushable) otherSprite.x += overlapX;" line64="                                else spriteA.x -= overlapX;" line65="                            }" line66="                        } else {" line67="                            if (spriteA.y &gt; otherSprite.y) {" line68="                                if (pushable) otherSprite.y -= overlapY;" line69="                                else spriteA.y += overlapY;" line70="                            } else {" line71="                                if (pushable) otherSprite.y += overlapY;" line72="                                else spriteA.y -= overlapY;" line73="                            }" line74="                        }" line75="" line76="                        if (!pushable) {" line77="                            spriteA.vx = 0;" line78="                            spriteA.vy = 0;" line79="                        }" line80="                        break;" line81="                    }" line82="                }" line83="            }" line84="        });" line85="    }" line86="" line87="    // =========================" line88="    // Generate Exact Bounding Box (No Extra Padding)" line89="    // =========================" line90="    function getBoundingBox(sprite: Sprite, addPadding: boolean = false): { left: number, right: number, top: number, bottom: number } {" line91="        let padding = addPadding ? Math.max(sprite.width, sprite.height) * 0.1 : 0;" line92="" line93="        return {" line94="            left: sprite.left - padding," line95="            right: sprite.right + padding," line96="            top: sprite.top - padding," line97="            bottom: sprite.bottom + padding" line98="        };" line99="    }" line100="" line101="    // =========================" line102="    // AABB Overlap Check" line103="    // =========================" line104="    function isAABBOverlapping(boxA: { left: number, right: number, top: number, bottom: number }," line105="        boxB: { left: number, right: number, top: number, bottom: number }): boolean {" line106="        return (" line107="            boxA.left &lt; boxB.right &amp;&amp;" line108="            boxA.right &gt; boxB.left &amp;&amp;" line109="            boxA.top &lt; boxB.bottom &amp;&amp;" line110="            boxA.bottom &gt; boxB.top" line111="        );" line112="    }" line113="}" numlines="114"></mutation></block></statement></block></xml>