<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="CRWH6ijJ`u;O29$0:c1S" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="(+L1BQv+UCJn`3w@)*pv" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace CollisionHandler {" line1="" line2="    /**" line3="     * Stops spriteA when colliding with spriteB (acts like a wall)." line4="     * @param spriteA The first sprite (the one that moves)." line5="     * @param spriteB The second sprite or a SpriteKind (stationary object)." line6="     */" line7="    //% block=&quot;stop $spriteA when colliding with $spriteB&quot;" line8="    //% group=&quot;Solid Collisions&quot;" line9="    //% spriteA.shadow=variables_get" line10="    //% spriteA.defl=mySprite" line11="    //% spriteB.shadow=variables_get" line12="    //% spriteB.shadow=spritekind" line13="    export function handleSolidCollision(spriteA: Sprite | number, spriteB: Sprite | number) {" line14="        handleAABBCollision(spriteA, spriteB, false);" line15="    }" line16="" line17="    /**" line18="     * Allows spriteA to push spriteB (pushable object)." line19="     * @param spriteA The first sprite (the one that moves)." line20="     * @param spriteB The second sprite or a SpriteKind (pushable object)." line21="     */" line22="    //% block=&quot;allow $spriteA to push $spriteB&quot;" line23="    //% group=&quot;Pushable Collisions&quot;" line24="    //% spriteA.shadow=variables_get" line25="    //% spriteA.defl=mySprite" line26="    //% spriteB.shadow=variables_get" line27="    //% spriteB.shadow=spritekind" line28="    //% color=&quot;#a349a4&quot; weight=80" line29="    export function handlePushableCollision(spriteA: Sprite | number, spriteB: Sprite | number) {" line30="        handleAABBCollision(spriteA, spriteB, true);" line31="    }" line32="" line33="    // =========================" line34="    // AABB Collision Handling" line35="    // =========================" line36="    function handleAABBCollision(spriteA: Sprite | number, spriteB: Sprite | number, pushable: boolean = false) {" line37="        game.onUpdate(function () {" line38="            let spritesToCheck: Sprite[] = [];" line39="" line40="            if (typeof spriteB === &quot;number&quot;) {" line41="                spritesToCheck = sprites.allOfKind(spriteB);" line42="            } else {" line43="                spritesToCheck = [spriteB];" line44="            }" line45="" line46="            for (let otherSprite of spritesToCheck) {" line47="                if (spriteA instanceof Sprite) {" line48="                    let boxA = getBoundingBox(spriteA, false);" line49="                    let boxB = getBoundingBox(otherSprite, false);" line50="" line51="                    if (isAABBOverlapping(boxA, boxB)) {" line52="                        let overlapX = Math.min(boxA.right - boxB.left, boxB.right - boxA.left);" line53="                        let overlapY = Math.min(boxA.bottom - boxB.top, boxB.bottom - boxA.top);" line54="" line55="                        if (overlapX &lt; overlapY) {" line56="                            if (spriteA.x &gt; otherSprite.x) {" line57="                                if (pushable) otherSprite.x -= overlapX;" line58="                                else spriteA.x += overlapX;" line59="                            } else {" line60="                                if (pushable) otherSprite.x += overlapX;" line61="                                else spriteA.x -= overlapX;" line62="                            }" line63="                        } else {" line64="                            if (spriteA.y &gt; otherSprite.y) {" line65="                                if (pushable) otherSprite.y -= overlapY;" line66="                                else spriteA.y += overlapY;" line67="                            } else {" line68="                                if (pushable) otherSprite.y += overlapY;" line69="                                else spriteA.y -= overlapY;" line70="                            }" line71="                        }" line72="" line73="                        if (!pushable) {" line74="                            spriteA.vx = 0;" line75="                            spriteA.vy = 0;" line76="                        }" line77="                        break;" line78="                    }" line79="                }" line80="            }" line81="        });" line82="    }" line83="" line84="    // =========================" line85="    // Generate Exact Bounding Box (No Extra Padding)" line86="    // =========================" line87="    function getBoundingBox(sprite: Sprite, addPadding: boolean = false): { left: number, right: number, top: number, bottom: number } {" line88="        let padding = addPadding ? Math.max(sprite.width, sprite.height) * 0.1 : 0;" line89="" line90="        return {" line91="            left: sprite.left - padding," line92="            right: sprite.right + padding," line93="            top: sprite.top - padding," line94="            bottom: sprite.bottom + padding" line95="        };" line96="    }" line97="" line98="    // =========================" line99="    // AABB Overlap Check" line100="    // =========================" line101="    function isAABBOverlapping(boxA: { left: number, right: number, top: number, bottom: number }," line102="        boxB: { left: number, right: number, top: number, bottom: number }): boolean {" line103="        return (" line104="            boxA.left &lt; boxB.right &amp;&amp;" line105="            boxA.right &gt; boxB.left &amp;&amp;" line106="            boxA.top &lt; boxB.bottom &amp;&amp;" line107="            boxA.bottom &gt; boxB.top" line108="        );" line109="    }" line110="}" numlines="111"></mutation></block></statement></block></xml>